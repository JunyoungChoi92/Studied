# Building Microservices: 마이크로서비스 아키텍쳐 구축

1. [마이크로 서비스](#chapter-1-마이크로-서비스)
2. [진화적 아키텍트](#chapter-2-진화적-아키텍트)
3. [서비스 모델링 하기](#)
4. [통합] (#)
5. [모놀리스 분해하기](#)
6. [배포](#)
7. [테스팅](#)
8. [모니터링](#)
9. [보안](#)
10. [콘웨이의 법칙과 시스템 설계](#)
11. [대규모 마이크로 서비스](#)
12. [종합 정리](#)

===

## Chapter 1. 마이크로 서비스

### 마이크로 서비스란

- **서비스란** 플랫폼에 종속되지 않은 표준 인터페이스를 통해 기업의 업무를 표현한, 느슨하게 결합되고 상호 조합이 가능한 독립적인 소프트웨어 컴포넌트를 말한다.

- 마이크로 서비스란 모놀리식 시스템(I/O, 프로세싱, 에러 처리 및 UI와 같은 기능들이 구분되어 있지 않고 서로 의존성을 가진 단일 시스템)과 구분되는 개념으로서, 단일 책임 원칙(SRP; Single Responsibility Principle. 하나의 객체는 하나의 책임을 부담한다는 객체지향의 한 원칙)을 따르는 **작은** 서비스이다.

- 마이크로 서비스는 서로 분리된 개체 또는 서비스로, 서로 독립적으로 변경될 수 있어야 하고, 서비스의 소비자 또는 마이크로 서비스를 호출하는 다른 서비스를 변경할 필요 없이 독립적으로 배포할 수 있어야 한다. 이는 서비스 간 의존성을 없에는 작업(**Decoupling; 디커플링**)을 통해 가능해진다.

### 마이크로 서비스의 강점

1. **서로 다른 환경(기종, 언어 등) 간 기술적 호환성** : 마이크로 서비스 아키텍쳐를 통해 각 서비스가 다른 기술을 사용하도록 할 수 있다. 이는 각 작업에 특화한 적절한 도구를 개발자가 직접 선택할 수 있도록 돕는다.
2. **회복성**: 마이크로 서비스는 책임 분리를 통해 상호간 격벽(bulkhead)이 있는 것 같이 기능한다. 즉, 한 시스템의 컴포넌트에 장애가 발생하더라도, 마이크로 서비스에서는 서비스 장애의 전파를 차단하고 기능을 적절히 저하(Degrading)시키는 시스템을 구축할 수 있다. 이를 결함 감내 시스템 또는 장애 허용 시스템(Fault tolerent system)이라고 부르며, 일부 장치나 서브 시스템에 오작동이 발생하면 시스템 성능과 기능을 축소 구성하여 전체 시스템이 정지하지 않고 동작을 유지하는 방식을 말한다(Gracdful degration; 단계별 성능 저하)
3. **확장성**: 모놀리식 서비스에서는 전체를 한 덩어리처럼 확장해야 하지만, 마이크로 서비스 아키텍쳐 아래 구현된 코드의 경우 일부 서비스를 교체하면 그만이다.
4. **배포 용이성**: 마이크로 서비스를 사용하면 하나의 서비스만 변경/ 수정할 수 있고, 나머지 시스템과 독립적으로 배포할 수 있다. 코드 배포가 더 신속하고, 문제가 발생하더라도 개별 서비스만 롤백하면 해당 문제를 격리할 수 있다.
5. **조직 부합성**: 생산성을 위해 조직 구조를 서비스에 맞게 재배치하거나 서비스 소유권을 이전하기 용이하다.
6. **조합성(Composability)**: 마이크로 서비스가 제공하는 기능을 재사용하는 데 용이하다. 가령 기존 서비스를 웹, 모바일 웹, 웨어러블 장치, 태블릿 등으로 확장할 때, 모놀리식 서비스와 비교해 재사용을 통한 신속한 개발에 용이하다.
7. **리팩토링**: 마이크로 서비스간 상호 독립성으로 인해, 기존 코드를 대체하는 코드를 개발하는 경우 모놀리식 서비스처럼 변형된 코드로 인한 복잡한 상호작용을 고려할 필요가 적다.

### 서비스 지향 아키텍쳐란

- 서비스 지향 아키텍쳐(SOA; Service-Oriented Architecture)란, 객제지향이나 컴포넌트 기반(Object-Oriented – Component-Based)의 한계를 극복하기 위해서 각종 이질적인(Heterogeneous)인 환경 위에 서비스 계층을 만들고, 모든 것을 서비스로 추상화함으로서 각종 컴퓨팅을 넘나 들며 통합이 가능하게 한 개념이다.

- 마이크로 서비스는 SOA 구현을 위한 특정한 접근법 또는 방법론의 하나로, 비유하자면 애자일 소프트웨어 개발과 Extreme programming, 스크럼간의 관계와 같다.

===

## Chapter 2. 진화적 아키텍트

### 부정확한 비교

- 아키텍트(Architect)란 다른 사람이 해석하고 실행할 수 있도록, 도구나 기술 등을 포함하여 세부적인 계획을 세우는 일을 말한다. "좋은" 아키텍트는 무엇인가?

### 아키텍트에 대한 진화적 관점

- 아키텍트는 실제 운영 환경(Production Environment) 속에서도 좋은 것을 향해서 계속해서 진화한다. 소프트웨어 아키텍쳐는 건물 설계보다 도시 설계에 가깝다. 가령 "특정 건물을 이렇게 만들라"기보다 도시를 <u>**구역화**</u> 하는 식이다.
- 도시 설계자로서 아키텍트는, 방향 자체는 개괄적으로 설정하되, 특정 경우 세부적으로 관여해야 한다. 시스템이 현재의 목적에 들어맞을 뿐 아니라, 미래의 플랫폼으로서 적합함을 보장해야 한다.

### 원칙적인 접근법

- 내 시스템 설계상의 결정이 최선임을 어떻게 확인할 수 있을까? 만약 그 결정이 불완전한 정보로 이루어져야 한다고 할 때에도 여전히 그 결정이 최선이라고 할 수 있을까?
- 다음과 같은 의사결정의 구조화(Framing) 전략이 도움이 될 수 있다.

  1. 전략적인 목표: 기술을 고려하는 단계 이전 단계로, 조직이 지향하는 바를 명확히 할 필요가 있다.
  2. 원칙(Principles): 전략적 목표를 달성하기 위해 해야 할 세부적인 일들을 정렬하는 공통 목표를 정의한다. 원칙은 변경될 수 있다. eg.) 새로운 제품의 시장 출시 시간 감축 등
  3. 실천사항(Practice): 원칙을 실행하기 위한 실질적인 방법, 자세, 지침 등을 일컫는다. eg.) HTTP/REST api를 사용한다는 약속이나 CentOS를 사용한다는 규칙 등.
  4. 실제 환경에 맞춰 위 세 요소간 작용을 도표로 그려보기.

### 필수 기준

- "자율적인 수명 주기를 가지면서도, 함께 협업하는 수많은 작은 서비스로 구성된 응집력있는 시스템"을 만들기 위하여, 각 서비스가 가져야 할 명확한 속성을 정의, 구분할 수 있어야 한다.
  1. 서비스 모니터링: 모든 서비스가 자기 상태와 일반적인 모니터링 관련 지표를 동일한 방식으로 한 곳으로 전송, 수집 및 관리할 수 있어야 한다.
  2. 인터페이스: 서비스 사이의 인터페이스 기술을 최소화/통합해야 한다.
  3. 아키텍쳐 안정성: 오작동하는 하나의 서비스가 전체 서비스를 망가트려선 안된다.

### 기술 부채와 예외 처리

===

## Chapter 3. 서비스 모델링 하기
